diff --git a/bta/dm/bta_dm_act.c b/bta/dm/bta_dm_act.c
old mode 100644
new mode 100755
index 2fa9d01..0b55142
--- a/bta/dm/bta_dm_act.c
+++ b/bta/dm/bta_dm_act.c
@@ -132,8 +132,10 @@ static void bta_dm_ctrl_features_rd_cmpl_cback(tBTM_STATUS result);
 
 static void bta_dm_reset_sec_dev_pending(BD_ADDR remote_bd_addr);
 static void bta_dm_remove_sec_dev_entry(BD_ADDR remote_bd_addr);
+    #if ((defined BTA_GATT_INCLUDED) &&  (BTA_GATT_INCLUDED == TRUE))
 static void bta_dm_observe_results_cb(tBTM_INQ_RESULTS *p_inq, UINT8 *p_eir);
 static void bta_dm_observe_cmpl_cb(void * p_result);
+	#endif
 static void bta_dm_delay_role_switch_cback(void *data);
 extern void sdpu_uuid16_to_uuid128(UINT16 uuid16, UINT8* p_uuid128);
 static void bta_dm_disable_timer_cback(void *data);
@@ -383,7 +385,9 @@ static void bta_dm_sys_hw_cback( tBTA_SYS_HW_EVT status )
 
         /* hw is ready, go on with BTA DM initialization */
         alarm_free(bta_dm_search_cb.search_timer);
+    #if ((defined BTA_GATT_INCLUDED) &&  (BTA_GATT_INCLUDED == TRUE))
         alarm_free(bta_dm_search_cb.gatt_close_timer);
+	#endif
         memset(&bta_dm_search_cb, 0, sizeof(bta_dm_search_cb));
         /*
          * TODO: Should alarm_free() the bta_dm_search_cb timers during
@@ -391,8 +395,10 @@ static void bta_dm_sys_hw_cback( tBTA_SYS_HW_EVT status )
          */
         bta_dm_search_cb.search_timer =
           alarm_new("bta_dm_search.search_timer");
+    #if ((defined BTA_GATT_INCLUDED) &&  (BTA_GATT_INCLUDED == TRUE))
         bta_dm_search_cb.gatt_close_timer =
           alarm_new("bta_dm_search.gatt_close_timer");
+	#endif
 
         memset(&bta_dm_conn_srvcs, 0, sizeof(bta_dm_conn_srvcs));
         memset(&bta_dm_di_cb, 0, sizeof(tBTA_DM_DI_CB));
@@ -710,7 +716,9 @@ void bta_dm_remove_device(tBTA_DM_MSG *p_data)
 
     /* If ACL exists for the device in the remove_bond message*/
     BOOLEAN continue_delete_dev = FALSE;
+    #if ((defined BTA_GATT_INCLUDED) &&  (BTA_GATT_INCLUDED == TRUE))
     UINT8 other_transport = BT_TRANSPORT_INVALID;
+	#endif
 
     if (BTM_IsAclConnectionUp(p_dev->bd_addr, BT_TRANSPORT_LE) ||
         BTM_IsAclConnectionUp(p_dev->bd_addr, BT_TRANSPORT_BR_EDR))
diff --git a/btif/src/btif_dm.c b/btif/src/btif_dm.c
old mode 100644
new mode 100755
index b1ad00b..cdc898c
--- a/btif/src/btif_dm.c
+++ b/btif/src/btif_dm.c
@@ -233,12 +233,12 @@ static void btif_dm_ble_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl);
 static void btif_dm_ble_passkey_req_evt(tBTA_DM_PIN_REQ *p_pin_req);
 static void btif_dm_ble_key_nc_req_evt(tBTA_DM_SP_KEY_NOTIF *p_notif_req) ;
 static void btif_dm_ble_oob_req_evt(tBTA_DM_SP_RMT_OOB *req_oob_type);
-#endif
 
 static void bte_scan_filt_param_cfg_evt(UINT8 action_type,
                                            tBTA_DM_BLE_PF_AVBL_SPACE avbl_space,
                                            tBTA_DM_BLE_REF_VALUE ref_value,
                                            tBTA_STATUS status);
+#endif
 
 static char* btif_get_default_local_name();
 
@@ -1364,7 +1364,9 @@ static void btif_dm_search_devices_evt (UINT16 event, char *p_param)
                 bt_device_type_t dev_type;
                 uint32_t num_properties = 0;
                 bt_status_t status;
+    #if ((defined BTA_GATT_INCLUDED) &&  (BTA_GATT_INCLUDED == TRUE))
                 int addr_type = 0;
+	#endif
 
                 memset(properties, 0, sizeof(properties));
                 /* BD_ADDR */
@@ -2235,6 +2237,7 @@ static void bta_energy_info_cb(tBTA_DM_BLE_TX_TIME_MS tx_time, tBTA_DM_BLE_RX_TI
 ** Returns          void
 **
 *******************************************************************************/
+#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
 static void bte_scan_filt_param_cfg_evt(UINT8 action_type,
                                         tBTA_DM_BLE_PF_AVBL_SPACE avbl_space,
                                         tBTA_DM_BLE_REF_VALUE ref_value, tBTA_STATUS status)
@@ -2251,7 +2254,7 @@ static void bte_scan_filt_param_cfg_evt(UINT8 action_type,
         BTIF_TRACE_DEBUG("%s", __FUNCTION__);
     }
 }
-
+#endif
 /*****************************************************************************
 **
 **   btif api functions (no context switch)
@@ -2271,7 +2274,9 @@ bt_status_t btif_dm_start_discovery(void)
 {
     tBTA_DM_INQ inq_params;
     tBTA_SERVICE_MASK services = 0;
+#if (BLE_INCLUDED == TRUE)
     tBTA_DM_BLE_PF_FILT_PARAMS adv_filt_param;
+#endif
 
     BTIF_TRACE_EVENT("%s", __FUNCTION__);
 
@@ -2680,9 +2685,10 @@ bt_status_t btif_dm_get_remote_services_by_transport(bt_bdaddr_t *remote_addr, c
     mask_ext.p_uuid = NULL;
     mask_ext.srvc_mask = BTA_ALL_SERVICE_MASK;
 
+    #if ((defined BTA_GATT_INCLUDED) &&  (BTA_GATT_INCLUDED == TRUE))
     BTA_DmDiscoverByTransport(remote_addr->address, &mask_ext,
                    bte_dm_search_services_evt, TRUE, transport);
-
+	#endif
     return BT_STATUS_SUCCESS;
 }
 
@@ -2914,12 +2920,15 @@ BOOLEAN btif_dm_get_smp_config(tBTE_APPL_CFG* p_cfg) {
 
     char conf[64];
     const char* recv = stack_config_get_interface()->get_pts_smp_options();
+#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
     char* pch;
     char* endptr;
+#endif
 
     strncpy(conf, recv, 64);
     conf[63] = 0; // null terminate
 
+#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
     if ((pch = strtok(conf, ",")) != NULL)
         p_cfg->ble_auth_req = (UINT8) strtoul(pch, &endptr, 16);
     else
@@ -2944,6 +2953,7 @@ BOOLEAN btif_dm_get_smp_config(tBTE_APPL_CFG* p_cfg) {
         p_cfg->ble_max_key_size =  (UINT8) strtoul(pch, &endptr, 16);
     else
         return FALSE;
+#endif
 
     return TRUE;
 }
diff --git a/btif/src/btif_storage.c b/btif/src/btif_storage.c
old mode 100644
new mode 100755
index 82d377d..34b2307
--- a/btif/src/btif_storage.c
+++ b/btif/src/btif_storage.c
@@ -162,9 +162,10 @@ extern void btif_gatts_add_bonded_dev_from_nv(BD_ADDR bda);
 /************************************************************************************
 **  Internal Functions
 ************************************************************************************/
-
+#if (BLE_INCLUDED == TRUE)
 static bt_status_t btif_in_fetch_bonded_ble_device(const char *remote_bd_addr,int add,
                                               btif_bonded_devices_t *p_bonded_devices);
+#endif
 static bt_status_t btif_in_fetch_bonded_device(const char *bdstr);
 
 /************************************************************************************
@@ -438,7 +439,9 @@ static bt_status_t btif_in_fetch_bonded_devices(btif_bonded_devices_t *p_bonded_
     memset(p_bonded_devices, 0, sizeof(btif_bonded_devices_t));
 
     BOOLEAN bt_linkkey_file_found=FALSE;
+#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
     int device_type;
+#endif
 
     for (const btif_config_section_iter_t *iter = btif_config_section_begin(); iter != btif_config_section_end(); iter = btif_config_section_next(iter)) {
         const char *name = btif_config_section_name(iter);
@@ -493,6 +496,7 @@ static bt_status_t btif_in_fetch_bonded_devices(btif_bonded_devices_t *p_bonded_
     return BT_STATUS_SUCCESS;
 }
 
+#if (BLE_INCLUDED == TRUE)
 static void btif_read_le_key(const uint8_t key_type, const size_t key_len, bt_bdaddr_t bd_addr,
                  const uint8_t addr_type, const bool add_key, bool *device_added, bool *key_found)
 {
@@ -502,6 +506,7 @@ static void btif_read_le_key(const uint8_t key_type, const size_t key_len, bt_bd
     char buffer[100];
     memset(buffer, 0, sizeof(buffer));
 
+#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
     if (btif_storage_get_ble_bonding_key(&bd_addr, key_type, buffer, key_len) == BT_STATUS_SUCCESS)
     {
         if (add_key)
@@ -523,7 +528,9 @@ static void btif_read_le_key(const uint8_t key_type, const size_t key_len, bt_bd
 
         *key_found = true;
     }
+#endif
 }
+#endif
 
 /*******************************************************************************
  * Functions
diff --git a/stack/btm/btm_sec.c b/stack/btm/btm_sec.c
old mode 100644
new mode 100755
index 83f6494..8da8e11
--- a/stack/btm/btm_sec.c
+++ b/stack/btm/btm_sec.c
@@ -6279,7 +6279,9 @@ BOOLEAN btm_sec_is_a_bonded_dev (BD_ADDR bda)
 *******************************************************************************/
 BOOLEAN btm_sec_is_le_capable_dev (BD_ADDR bda)
 {
+#if (BLE_INCLUDED == TRUE)
     tBTM_SEC_DEV_REC *p_dev_rec= btm_find_dev (bda);
+#endif
     BOOLEAN le_capable = FALSE;
 
 #if (BLE_INCLUDED== TRUE)
diff --git a/stack/l2cap/l2c_csm.c b/stack/l2cap/l2c_csm.c
old mode 100644
new mode 100755
index dedffc8..367ea85
--- a/stack/l2cap/l2c_csm.c
+++ b/stack/l2cap/l2c_csm.c
@@ -172,8 +172,10 @@ static void l2c_csm_closed (tL2C_CCB *p_ccb, UINT16 event, void *p_data)
         if (p_ccb->p_lcb->transport == BT_TRANSPORT_LE)
         {
             p_ccb->chnl_state = CST_ORIG_W4_SEC_COMP;
+#if (BLE_INCLUDED == TRUE)
             l2ble_sec_access_req(p_ccb->p_lcb->remote_bd_addr, p_ccb->p_rcb->psm, TRUE,
                     &l2c_link_sec_comp, p_ccb);
+#endif
         }
         else
         {
@@ -198,8 +200,10 @@ static void l2c_csm_closed (tL2C_CCB *p_ccb, UINT16 event, void *p_data)
         if (p_ccb->p_lcb->transport == BT_TRANSPORT_LE)
         {
             p_ccb->chnl_state = CST_ORIG_W4_SEC_COMP;
+#if (BLE_INCLUDED == TRUE)
             l2ble_sec_access_req(p_ccb->p_lcb->remote_bd_addr, p_ccb->p_rcb->psm, TRUE,
                     &l2c_link_sec_comp, p_ccb);
+#endif
         }
         else
         {
@@ -261,8 +265,10 @@ Event uninit_use_in_call: Using uninitialized value "settings.min" in call to fu
         if (p_ccb->p_lcb->transport == BT_TRANSPORT_LE)
         {
             p_ccb->chnl_state = CST_TERM_W4_SEC_COMP;
+#if (BLE_INCLUDED == TRUE)
              l2ble_sec_access_req(p_ccb->p_lcb->remote_bd_addr, p_ccb->p_rcb->psm, FALSE,
                     &l2c_link_sec_comp, p_ccb);
+#endif
         }
         else
         {
@@ -360,8 +366,10 @@ static void l2c_csm_orig_w4_sec_comp (tL2C_CCB *p_ccb, UINT16 event, void *p_dat
     case L2CEVT_LP_CONNECT_CFM:                     /* Link came up         */
         if (p_ccb->p_lcb->transport == BT_TRANSPORT_LE)
         {
+#if (BLE_INCLUDED == TRUE)
              l2ble_sec_access_req(p_ccb->p_lcb->remote_bd_addr, p_ccb->p_rcb->psm, FALSE,
                     &l2c_link_sec_comp, p_ccb);
+#endif
         }
         else
         {
@@ -379,7 +387,9 @@ static void l2c_csm_orig_w4_sec_comp (tL2C_CCB *p_ccb, UINT16 event, void *p_dat
                                L2CAP_CHNL_CONNECT_TIMEOUT_MS,
                                l2c_ccb_timer_timeout, p_ccb,
                                btu_general_alarm_queue);
+#if (BLE_INCLUDED == TRUE)
             l2cble_credit_based_conn_req (p_ccb);          /* Start Connection     */
+#endif
         }
         else
         {
@@ -514,9 +524,11 @@ static void l2c_csm_term_w4_sec_comp (tL2C_CCB *p_ccb, UINT16 event, void *p_dat
         }
         else
         {
-            if (p_ccb->p_lcb->transport == BT_TRANSPORT_LE)
+            if (p_ccb->p_lcb->transport == BT_TRANSPORT_LE) {
+#if (BLE_INCLUDED == TRUE)
                 l2cu_reject_ble_connection(p_ccb->p_lcb, p_ccb->remote_id, L2CAP_LE_INSUFFICIENT_AUTHENTICATION);
-            else
+#endif
+            } else
                 l2cu_send_peer_connect_rsp (p_ccb, L2CAP_CONN_SECURITY_BLOCK, 0);
             l2cu_release_ccb (p_ccb);
         }
@@ -726,13 +738,17 @@ static void l2c_csm_w4_l2ca_connect_rsp (tL2C_CCB *p_ccb, UINT16 event, void *p_
             /* Result should be OK or Reject */
             if ((!p_ci) || (p_ci->l2cap_result == L2CAP_CONN_OK))
             {
+#if (BLE_INCLUDED == TRUE)
                 l2cble_credit_based_conn_res (p_ccb, L2CAP_CONN_OK);
+#endif
                 p_ccb->chnl_state = CST_OPEN;
                 alarm_cancel(p_ccb->l2c_ccb_timer);
             }
             else
             {
+#if (BLE_INCLUDED == TRUE)
                 l2cble_credit_based_conn_res (p_ccb, p_ci->l2cap_result);
+#endif
                 l2cu_release_ccb (p_ccb);
             }
         }
@@ -763,7 +779,11 @@ static void l2c_csm_w4_l2ca_connect_rsp (tL2C_CCB *p_ccb, UINT16 event, void *p_
     case L2CEVT_L2CA_CONNECT_RSP_NEG:
         p_ci = (tL2C_CONN_INFO *)p_data;
         if (p_ccb->p_lcb->transport == BT_TRANSPORT_LE)
+#if (BLE_INCLUDED == TRUE)
             l2cble_credit_based_conn_res (p_ccb, p_ci->l2cap_result);
+#else
+{}
+#endif
         else
             l2cu_send_peer_connect_rsp (p_ccb, p_ci->l2cap_result, p_ci->l2cap_status);
         l2cu_release_ccb (p_ccb);
@@ -1185,9 +1205,11 @@ static void l2c_csm_open (tL2C_CCB *p_ccb, UINT16 event, void *p_data)
             }
         }
 
-        if (p_ccb->p_lcb->transport == BT_TRANSPORT_LE)
+        if (p_ccb->p_lcb->transport == BT_TRANSPORT_LE) {
+#if (BLE_INCLUDED == TRUE)
             l2cble_send_peer_disc_req (p_ccb);
-        else
+#endif
+        } else
             l2cu_send_peer_disc_req (p_ccb);
 
         p_ccb->chnl_state = CST_W4_L2CAP_DISCONNECT_RSP;
@@ -1226,7 +1248,9 @@ static void l2c_csm_open (tL2C_CCB *p_ccb, UINT16 event, void *p_data)
     case L2CEVT_L2CA_SEND_FLOW_CONTROL_CREDIT:
         L2CAP_TRACE_DEBUG("%s Sending credit",__func__);
         credit = (UINT16*)p_data;
+#if (BLE_INCLUDED == TRUE)
         l2cble_send_flow_control_credit(p_ccb, *credit);
+#endif
         break;
 
     case L2CEVT_L2CAP_RECV_FLOW_CONTROL_CREDIT:
@@ -1237,7 +1261,9 @@ static void l2c_csm_open (tL2C_CCB *p_ccb, UINT16 event, void *p_data)
             /* we have received credits more than max coc credits,
              * so disconnecting the Le Coc Channel
              */
+#if (BLE_INCLUDED == TRUE)
             l2cble_send_peer_disc_req (p_ccb);
+#endif
         }
         else
         {
diff --git a/stack/l2cap/l2c_utils.c b/stack/l2cap/l2c_utils.c
old mode 100644
new mode 100755
index 58ac4b0..63a159b
--- a/stack/l2cap/l2c_utils.c
+++ b/stack/l2cap/l2c_utils.c
@@ -253,6 +253,7 @@ void l2cu_release_lcb (tL2C_LCB *p_lcb)
         (*p_cb) (L2CAP_PING_RESULT_NO_LINK);
     }
 
+#if (BLE_INCLUDED == TRUE)
     /* Check and release all the LE COC connections waiting for security */
     if (p_lcb->le_sec_pending_q)
     {
@@ -266,6 +267,7 @@ void l2cu_release_lcb (tL2C_LCB *p_lcb)
         fixed_queue_free(p_lcb->le_sec_pending_q, NULL);
         p_lcb->le_sec_pending_q = NULL;
     }
+#endif
 }
 
 
@@ -1829,6 +1831,7 @@ tL2C_RCB *l2cu_allocate_rcb (UINT16 psm)
 *******************************************************************************/
 tL2C_RCB *l2cu_allocate_ble_rcb (UINT16 psm)
 {
+#if (BLE_INCLUDED == TRUE)
     tL2C_RCB    *p_rcb = &l2cb.ble_rcb_pool[0];
     UINT16      xx;
 
@@ -1844,7 +1847,7 @@ tL2C_RCB *l2cu_allocate_ble_rcb (UINT16 psm)
             return (p_rcb);
         }
     }
-
+#endif
     /* If here, no free RCB found */
     return (NULL);
 }
@@ -1934,6 +1937,7 @@ tL2C_RCB *l2cu_find_rcb_by_psm (UINT16 psm)
 *******************************************************************************/
 tL2C_RCB *l2cu_find_ble_rcb_by_psm (UINT16 psm)
 {
+#if (BLE_INCLUDED == TRUE)
     tL2C_RCB    *p_rcb = &l2cb.ble_rcb_pool[0];
     UINT16      xx;
 
@@ -1942,7 +1946,7 @@ tL2C_RCB *l2cu_find_ble_rcb_by_psm (UINT16 psm)
         if ((p_rcb->in_use) && (p_rcb->psm == psm))
             return (p_rcb);
     }
-
+#endif
     /* If here, no match found */
     return (NULL);
 }
