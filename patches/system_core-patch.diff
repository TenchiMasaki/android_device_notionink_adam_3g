diff --git a/fs_mgr/fs_mgr.c b/fs_mgr/fs_mgr.c
old mode 100644
new mode 100755
index 15d44ef..a92ac59
--- a/fs_mgr/fs_mgr.c
+++ b/fs_mgr/fs_mgr.c
@@ -60,6 +60,7 @@
 #define FSCK_LOG_FILE   "/dev/fscklogs/log"
 
 #define ZRAM_CONF_DEV   "/sys/block/zram0/disksize"
+#define ZRAM_STREAMS    "/sys/block/zram0/max_comp_streams"
 
 #define ARRAY_SIZE(a) (sizeof(a) / sizeof(*(a)))
 
@@ -159,12 +160,12 @@ static void check_fs(char *blk_device, char *fs_type, char *target)
             }
         }
     } else if (!strcmp(fs_type, "f2fs")) {
-            char *f2fs_fsck_argv[] = {
-                    F2FS_FSCK_BIN,
-                    "-f",
-                    blk_device
-            };
-        INFO("Running %s -f %s\n", F2FS_FSCK_BIN, blk_device);
+        char *f2fs_fsck_argv[] = {
+            F2FS_FSCK_BIN,
+            "-a",
+            blk_device
+        };
+        INFO("Running %s on %s\n", F2FS_FSCK_BIN, blk_device);
 
         ret = android_fork_execvp_ext(ARRAY_SIZE(f2fs_fsck_argv), f2fs_fsck_argv,
                                       &status, true, LOG_KLOG | LOG_FILE,
@@ -492,6 +493,52 @@ static int handle_encryptable(struct fstab *fstab, const struct fstab_rec* rec)
     return FS_MGR_MNTALL_DEV_NOT_ENCRYPTED;
 }
 
+/*
+ * Reads the kernel cmdline to check if MDTP is activated.
+ * When MDTP is activated, kernel cmdline will have the word 'mdtp'.
+ */
+int fs_mgr_is_mdtp_activated()
+{
+      char cmdline[2048];
+      char *ptr;
+      int fd;
+      static int mdtp_activated = 0;
+      static int mdtp_activated_set = 0;
+
+      if (mdtp_activated_set) {
+          return mdtp_activated;
+      }
+
+      fd = open("/proc/cmdline", O_RDONLY);
+      if (fd >= 0) {
+          int n = read(fd, cmdline, sizeof(cmdline) - 1);
+          if (n < 0) n = 0;
+
+          /* get rid of trailing newline, it happens */
+          if (n > 0 && cmdline[n-1] == '\n') n--;
+
+          cmdline[n] = 0;
+          close(fd);
+      } else {
+          cmdline[0] = 0;
+      }
+
+      ptr = cmdline;
+      while (ptr && *ptr) {
+          char *x = strchr(ptr, ' ');
+          if (x != 0) *x++ = 0;
+          if (!strcmp(ptr,"mdtp")) {
+            mdtp_activated = 1;
+            break;
+          }
+          ptr = x;
+      }
+
+      mdtp_activated_set = 1;
+
+      return mdtp_activated;
+}
+
 /* When multiple fstab records share the same mount_point, it will
  * try to mount each one in turn, and ignore any duplicates after a
  * first successful mount.
@@ -547,91 +594,106 @@ int fs_mgr_mount_all(struct fstab *fstab)
                 continue;
             }
         }
-        int last_idx_inspected;
-        int top_idx = i;
 
-        mret = mount_with_alternatives(fstab, i, &last_idx_inspected, &attempted_idx);
-        i = last_idx_inspected;
-        mount_errno = errno;
+        if (fs_mgr_is_mdtp_activated() && ((fstab->recs[i].fs_mgr_flags & MF_FORCECRYPT) ||
+            device_is_force_encrypted())) {
+            INFO("%s(): mdtp activated, blkdev %s for mount %s type %s expected to be encrypted)\n",
+                 __func__, fstab->recs[i].blk_device, fstab->recs[i].mount_point,
+                 fstab->recs[i].fs_type);
+            if (fs_mgr_do_tmpfs_mount(fstab->recs[i].mount_point) < 0) {
+                ++error_count;
+                continue;
+            }
 
-        /* Deal with encryptability. */
-        if (!mret) {
-            int status = handle_encryptable(fstab, &fstab->recs[attempted_idx]);
+            encryptable = FS_MGR_MNTALL_DEV_MIGHT_BE_ENCRYPTED;
 
-            if (status == FS_MGR_MNTALL_FAIL) {
-                /* Fatal error - no point continuing */
-                return status;
-            }
+        } else {
+            int last_idx_inspected;
+            int top_idx = i;
 
-            if (status != FS_MGR_MNTALL_DEV_NOT_ENCRYPTED) {
-                if (encryptable != FS_MGR_MNTALL_DEV_NOT_ENCRYPTED) {
-                    // Log and continue
-                    ERROR("Only one encryptable/encrypted partition supported\n");
-                }
-                encryptable = status;
-            }
+            mret = mount_with_alternatives(fstab, i, &last_idx_inspected, &attempted_idx);
+            i = last_idx_inspected;
+            mount_errno = errno;
 
-            /* Success!  Go get the next one */
-            continue;
-        }
+            /* Deal with encryptability. */
+            if (!mret) {
+                int status = handle_encryptable(fstab, &fstab->recs[attempted_idx]);
 
-        /* mount(2) returned an error, handle the encryptable/formattable case */
-        bool wiped = partition_wiped(fstab->recs[top_idx].blk_device);
-        if (mret && mount_errno != EBUSY && mount_errno != EACCES &&
-            fs_mgr_is_formattable(&fstab->recs[top_idx]) && wiped) {
-            /* top_idx and attempted_idx point at the same partition, but sometimes
-             * at two different lines in the fstab.  Use the top one for formatting
-             * as that is the preferred one.
-             */
-            ERROR("%s(): %s is wiped and %s %s is formattable. Format it.\n", __func__,
-                  fstab->recs[top_idx].blk_device, fstab->recs[top_idx].mount_point,
-                  fstab->recs[top_idx].fs_type);
-            if (fs_mgr_is_encryptable(&fstab->recs[top_idx]) &&
-                strcmp(fstab->recs[top_idx].key_loc, KEY_IN_FOOTER)) {
-                int fd = open(fstab->recs[top_idx].key_loc, O_WRONLY, 0644);
-                if (fd >= 0) {
-                    INFO("%s(): also wipe %s\n", __func__, fstab->recs[top_idx].key_loc);
-                    wipe_block_device(fd, get_file_size(fd));
-                    close(fd);
-                } else {
-                    ERROR("%s(): %s wouldn't open (%s)\n", __func__,
-                          fstab->recs[top_idx].key_loc, strerror(errno));
+                if (status == FS_MGR_MNTALL_FAIL) {
+                    /* Fatal error - no point continuing */
+                    return status;
                 }
-            }
-            if (fs_mgr_do_format(&fstab->recs[top_idx]) == 0) {
-                /* Let's replay the mount actions. */
-                i = top_idx - 1;
+
+                if (status != FS_MGR_MNTALL_DEV_NOT_ENCRYPTED) {
+                    if (encryptable != FS_MGR_MNTALL_DEV_NOT_ENCRYPTED) {
+                        // Log and continue
+                        ERROR("Only one encryptable/encrypted partition supported\n");
+                    }
+                    encryptable = status;
+                }
+
+                /* Success!  Go get the next one */
                 continue;
             }
-        }
-        if (mret && mount_errno != EBUSY && mount_errno != EACCES &&
-            fs_mgr_is_encryptable(&fstab->recs[attempted_idx])) {
-            if (wiped) {
-                ERROR("%s(): %s is wiped and %s %s is encryptable. Suggest recovery...\n", __func__,
-                      fstab->recs[attempted_idx].blk_device, fstab->recs[attempted_idx].mount_point,
-                      fstab->recs[attempted_idx].fs_type);
-                encryptable = FS_MGR_MNTALL_DEV_NEEDS_RECOVERY;
-                continue;
-            } else {
-                /* Need to mount a tmpfs at this mountpoint for now, and set
-                 * properties that vold will query later for decrypting
+
+            /* mount(2) returned an error, handle the encryptable/formattable case */
+            bool wiped = partition_wiped(fstab->recs[top_idx].blk_device);
+            if (mret && mount_errno != EBUSY && mount_errno != EACCES &&
+                fs_mgr_is_formattable(&fstab->recs[top_idx]) && wiped) {
+                /* top_idx and attempted_idx point at the same partition, but sometimes
+                 * at two different lines in the fstab.  Use the top one for formatting
+                 * as that is the preferred one.
                  */
-                ERROR("%s(): possibly an encryptable blkdev %s for mount %s type %s )\n", __func__,
-                      fstab->recs[attempted_idx].blk_device, fstab->recs[attempted_idx].mount_point,
-                      fstab->recs[attempted_idx].fs_type);
-                if (fs_mgr_do_tmpfs_mount(fstab->recs[attempted_idx].mount_point) < 0) {
-                    ++error_count;
+                ERROR("%s(): %s is wiped and %s %s is formattable. Format it.\n", __func__,
+                      fstab->recs[top_idx].blk_device, fstab->recs[top_idx].mount_point,
+                      fstab->recs[top_idx].fs_type);
+                if (fs_mgr_is_encryptable(&fstab->recs[top_idx]) &&
+                    strcmp(fstab->recs[top_idx].key_loc, KEY_IN_FOOTER)) {
+                    int fd = open(fstab->recs[top_idx].key_loc, O_WRONLY, 0644);
+                    if (fd >= 0) {
+                        INFO("%s(): also wipe %s\n", __func__, fstab->recs[top_idx].key_loc);
+                        wipe_block_device(fd, get_file_size(fd));
+                        close(fd);
+                    } else {
+                        ERROR("%s(): %s wouldn't open (%s)\n", __func__,
+                              fstab->recs[top_idx].key_loc, strerror(errno));
+                    }
+                }
+                if (fs_mgr_do_format(&fstab->recs[top_idx]) == 0) {
+                    /* Let's replay the mount actions. */
+                    i = top_idx - 1;
                     continue;
                 }
             }
-            encryptable = FS_MGR_MNTALL_DEV_MIGHT_BE_ENCRYPTED;
-        } else {
-            ERROR("Failed to mount an un-encryptable or wiped partition on"
-                   "%s at %s options: %s error: %s\n",
-                   fstab->recs[attempted_idx].blk_device, fstab->recs[attempted_idx].mount_point,
-                   fstab->recs[attempted_idx].fs_options, strerror(mount_errno));
-            ++error_count;
-            continue;
+            if (mret && mount_errno != EBUSY && mount_errno != EACCES &&
+                fs_mgr_is_encryptable(&fstab->recs[attempted_idx])) {
+                if (wiped) {
+                    ERROR("%s(): %s is wiped and %s %s is encryptable. Suggest recovery...\n", __func__,
+                          fstab->recs[attempted_idx].blk_device, fstab->recs[attempted_idx].mount_point,
+                          fstab->recs[attempted_idx].fs_type);
+                    encryptable = FS_MGR_MNTALL_DEV_NEEDS_RECOVERY;
+                    continue;
+                } else {
+                    /* Need to mount a tmpfs at this mountpoint for now, and set
+                     * properties that vold will query later for decrypting
+                     */
+                    ERROR("%s(): possibly an encryptable blkdev %s for mount %s type %s )\n", __func__,
+                          fstab->recs[attempted_idx].blk_device, fstab->recs[attempted_idx].mount_point,
+                          fstab->recs[attempted_idx].fs_type);
+                    if (fs_mgr_do_tmpfs_mount(fstab->recs[attempted_idx].mount_point) < 0) {
+                        ++error_count;
+                        continue;
+                    }
+                }
+                encryptable = FS_MGR_MNTALL_DEV_MIGHT_BE_ENCRYPTED;
+            } else {
+                ERROR("Failed to mount an un-encryptable or wiped partition on"
+                       "%s at %s options: %s error: %s\n",
+                       fstab->recs[attempted_idx].blk_device, fstab->recs[attempted_idx].mount_point,
+                       fstab->recs[attempted_idx].fs_options, strerror(mount_errno));
+                ++error_count;
+                continue;
+            }
         }
     }
 
@@ -799,6 +861,14 @@ int fs_mgr_swapon_all(struct fstab *fstab)
              */
             FILE *zram_fp;
 
+            /* The stream count parameter is only available on new kernels.
+             * It must be set before the disk size. */
+            zram_fp = fopen(ZRAM_STREAMS, "r+");
+            if (zram_fp) {
+                fprintf(zram_fp, "%d\n", fstab->recs[i].zram_streams);
+                fclose(zram_fp);
+            }
+
             zram_fp = fopen(ZRAM_CONF_DEV, "r+");
             if (zram_fp == NULL) {
                 ERROR("Unable to open zram conf device %s\n", ZRAM_CONF_DEV);
diff --git a/fs_mgr/fs_mgr_format.c b/fs_mgr/fs_mgr_format.c
old mode 100644
new mode 100755
index c73045d..7b6a40f
--- a/fs_mgr/fs_mgr_format.c
+++ b/fs_mgr/fs_mgr_format.c
@@ -31,7 +31,7 @@
 extern struct fs_info info;     /* magic global from ext4_utils */
 extern void reset_ext4fs_info();
 
-static int format_ext4(char *fs_blkdev, char *fs_mnt_point)
+static int format_ext4(char *fs_blkdev, char *fs_mnt_point, long long fs_length)
 {
     unsigned int nr_sec;
     int fd, rc = 0;
@@ -51,6 +51,12 @@ static int format_ext4(char *fs_blkdev, char *fs_mnt_point)
     reset_ext4fs_info();
     info.len = ((off64_t)nr_sec * 512);
 
+    if (fs_length > 0) {
+        info.len = fs_length;
+    } else if (fs_length < 0) {
+        info.len += fs_length;
+    }
+
     /* Use make_ext4fs_internal to avoid wiping an already-wiped partition. */
     rc = make_ext4fs_internal(fd, NULL, NULL, fs_mnt_point, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL);
     if (rc) {
@@ -61,15 +67,27 @@ static int format_ext4(char *fs_blkdev, char *fs_mnt_point)
     return rc;
 }
 
-static int format_f2fs(char *fs_blkdev)
+static int format_f2fs(char *fs_blkdev, long long fs_length)
 {
-    char * args[3];
+    char * args[5];
     int pid;
     int rc = 0;
+    char buff[65];
 
     args[0] = (char *)"/sbin/mkfs.f2fs";
-    args[1] = fs_blkdev;
-    args[2] = (char *)0;
+
+    if (fs_length >= 0) {
+        snprintf(buff, sizeof(buff), "%lld", fs_length / 512);
+        args[1] = fs_blkdev;
+        args[2] = buff;
+        args[3] = (char *)0;
+    } else if (fs_length < 0) {
+        snprintf(buff, sizeof(buff), "%lld", -fs_length);
+        args[1] = "-r";
+        args[2] = buff;
+        args[3] = fs_blkdev;
+        args[4] = (char *)0;
+    }
 
     pid = fork();
     if (pid < 0) {
@@ -108,9 +126,9 @@ int fs_mgr_do_format(struct fstab_rec *fstab)
     ERROR("%s: Format %s as '%s'.\n", __func__, fstab->blk_device, fstab->fs_type);
 
     if (!strncmp(fstab->fs_type, "f2fs", 4)) {
-        rc = format_f2fs(fstab->blk_device);
+        rc = format_f2fs(fstab->blk_device, fstab->length);
     } else if (!strncmp(fstab->fs_type, "ext4", 4)) {
-        rc = format_ext4(fstab->blk_device, fstab->mount_point);
+        rc = format_ext4(fstab->blk_device, fstab->mount_point, fstab->length);
     } else {
         ERROR("File system type '%s' is not supported\n", fstab->fs_type);
     }
diff --git a/fs_mgr/fs_mgr_fstab.c b/fs_mgr/fs_mgr_fstab.c
old mode 100644
new mode 100755
index f24af1f..b1b0325
--- a/fs_mgr/fs_mgr_fstab.c
+++ b/fs_mgr/fs_mgr_fstab.c
@@ -32,6 +32,7 @@ struct fs_mgr_flag_values {
     int partnum;
     int swap_prio;
     unsigned int zram_size;
+    unsigned int zram_streams;
 };
 
 struct flag_list {
@@ -74,6 +75,7 @@ static struct flag_list fs_mgr_flags[] = {
     { "noemulatedsd", MF_NOEMULATEDSD },
     { "notrim",       MF_NOTRIM },
     { "formattable", MF_FORMATTABLE },
+    { "zramstreams=",MF_ZRAMSTREAMS },
     { "defaults",    0 },
     { 0,             0 },
 };
@@ -106,6 +108,7 @@ static int parse_flags(char *flags, struct flag_list *fl,
         memset(flag_vals, 0, sizeof(*flag_vals));
         flag_vals->partnum = -1;
         flag_vals->swap_prio = -1; /* negative means it wasn't specified. */
+        flag_vals->zram_streams = 1;
     }
 
     /* initialize fs_options to the null string */
@@ -178,6 +181,8 @@ static int parse_flags(char *flags, struct flag_list *fl,
                         flag_vals->zram_size = calculate_zram_size(val);
                     else
                         flag_vals->zram_size = val;
+                } else if ((fl[i].flag == MF_ZRAMSTREAMS) && flag_vals) {
+                    flag_vals->zram_streams = strtoll(strchr(p, '=') + 1, NULL, 0);
                 }
                 break;
             }
@@ -329,6 +334,7 @@ struct fstab *fs_mgr_read_fstab(const char *fstab_path)
         fstab->recs[cnt].partnum = flag_vals.partnum;
         fstab->recs[cnt].swap_prio = flag_vals.swap_prio;
         fstab->recs[cnt].zram_size = flag_vals.zram_size;
+        fstab->recs[cnt].zram_streams = flag_vals.zram_streams;
         cnt++;
     }
     fclose(fstab_file);
diff --git a/fs_mgr/fs_mgr_priv.h b/fs_mgr/fs_mgr_priv.h
old mode 100644
new mode 100755
index 682fd11..b72e200
--- a/fs_mgr/fs_mgr_priv.h
+++ b/fs_mgr/fs_mgr_priv.h
@@ -79,6 +79,7 @@
 #define MF_NOTRIM       0x1000
 #define MF_FILEENCRYPTION 0x2000
 #define MF_FORMATTABLE  0x4000
+#define MF_ZRAMSTREAMS  0x8000
 
 #define DM_BUF_SIZE 4096
 
diff --git a/fs_mgr/fs_mgr_verity.c b/fs_mgr/fs_mgr_verity.c
old mode 100644
new mode 100755
index 8130ae6..a9e3358
--- a/fs_mgr/fs_mgr_verity.c
+++ b/fs_mgr/fs_mgr_verity.c
@@ -870,9 +870,8 @@ int fs_mgr_load_verity_state(int *mode)
             continue;
         }
 
-        if (current != VERITY_MODE_DEFAULT) {
+        if (current == VERITY_MODE_LOGGING) {
             *mode = current;
-            break;
         }
     }
 
@@ -906,13 +905,12 @@ int fs_mgr_update_verity_state(fs_mgr_verity_state_callback callback)
     property_get("ro.boot.veritymode", propbuf, "");
 
     if (*propbuf != '\0') {
+        if (fs_mgr_load_verity_state(&mode) == -1) {
+            return -1;
+        }
         use_state = false; /* state is kept by the bootloader */
     }
 
-    if (fs_mgr_load_verity_state(&mode) == -1) {
-        return -1;
-    }
-
     fd = TEMP_FAILURE_RETRY(open("/dev/device-mapper", O_RDWR | O_CLOEXEC));
 
     if (fd == -1) {
@@ -935,6 +933,13 @@ int fs_mgr_update_verity_state(fs_mgr_verity_state_callback callback)
             continue;
         }
 
+        if (use_state) {
+            if (get_verity_state_offset(&fstab->recs[i], &offset) < 0 ||
+                read_verity_state(fstab->recs[i].verity_loc, offset, &mode) < 0) {
+                continue;
+            }
+        }
+
         mount_point = basename(fstab->recs[i].mount_point);
         verity_ioctl_init(io, mount_point, 0);
 
diff --git a/fs_mgr/include/fs_mgr.h b/fs_mgr/include/fs_mgr.h
old mode 100644
new mode 100755
index 27fccf7..5e05d9a
--- a/fs_mgr/include/fs_mgr.h
+++ b/fs_mgr/include/fs_mgr.h
@@ -65,6 +65,7 @@ struct fstab_rec {
     int partnum;
     int swap_prio;
     unsigned int zram_size;
+    unsigned int zram_streams;
 };
 
 // Callback function for verity status
@@ -97,6 +98,7 @@ int fs_mgr_add_entry(struct fstab *fstab,
                      const char *mount_point, const char *fs_type,
                      const char *blk_device);
 struct fstab_rec *fs_mgr_get_entry_for_mount_point(struct fstab *fstab, const char *path);
+struct fstab_rec *fs_mgr_get_entry_for_mount_point_after(struct fstab_rec *start_rec, struct fstab *fstab, const char *path);
 int fs_mgr_is_voldmanaged(const struct fstab_rec *fstab);
 int fs_mgr_is_nonremovable(const struct fstab_rec *fstab);
 int fs_mgr_is_verified(const struct fstab_rec *fstab);
@@ -106,6 +108,7 @@ int fs_mgr_is_noemulatedsd(const struct fstab_rec *fstab);
 int fs_mgr_is_notrim(struct fstab_rec *fstab);
 int fs_mgr_is_formattable(struct fstab_rec *fstab);
 int fs_mgr_swapon_all(struct fstab *fstab);
+int fs_mgr_is_mdtp_activated(void);
 
 int fs_mgr_do_format(struct fstab_rec *fstab);
 
diff --git a/include/cutils/iosched_policy.h b/include/cutils/iosched_policy.h
old mode 100644
new mode 100755
index 07c5d1f..25b87ba
--- a/include/cutils/iosched_policy.h
+++ b/include/cutils/iosched_policy.h
@@ -31,6 +31,8 @@ typedef enum {
 extern int android_set_ioprio(int pid, IoSchedClass clazz, int ioprio);
 extern int android_get_ioprio(int pid, IoSchedClass *clazz, int *ioprio);
 
+extern int android_set_rt_ioprio(int pid, int rt);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/utils/VectorImpl.h b/include/utils/VectorImpl.h
old mode 100644
new mode 100755
index 21ad71c..88c3a05
--- a/include/utils/VectorImpl.h
+++ b/include/utils/VectorImpl.h
@@ -105,7 +105,19 @@ protected:
     virtual void            do_splat(void* dest, const void* item, size_t num) const = 0;
     virtual void            do_move_forward(void* dest, const void* from, size_t num) const = 0;
     virtual void            do_move_backward(void* dest, const void* from, size_t num) const = 0;
-    
+
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+    // take care of FBC...
+    virtual void            reservedVectorImpl1();
+    virtual void            reservedVectorImpl2();
+    virtual void            reservedVectorImpl3();
+    virtual void            reservedVectorImpl4();
+    virtual void            reservedVectorImpl5();
+    virtual void            reservedVectorImpl6();
+    virtual void            reservedVectorImpl7();
+    virtual void            reservedVectorImpl8();
+#endif
+
 private:
         void* _grow(size_t where, size_t amount);
         void  _shrink(size_t where, size_t amount);
@@ -156,6 +168,18 @@ public:
 protected:
     virtual int             do_compare(const void* lhs, const void* rhs) const = 0;
 
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+    // take care of FBC...
+    virtual void            reservedSortedVectorImpl1();
+    virtual void            reservedSortedVectorImpl2();
+    virtual void            reservedSortedVectorImpl3();
+    virtual void            reservedSortedVectorImpl4();
+    virtual void            reservedSortedVectorImpl5();
+    virtual void            reservedSortedVectorImpl6();
+    virtual void            reservedSortedVectorImpl7();
+    virtual void            reservedSortedVectorImpl8();
+#endif
+
 private:
             ssize_t         _indexOrderOf(const void* item, size_t* order = 0) const;
 
diff --git a/init/Android.mk b/init/Android.mk
old mode 100644
new mode 100755
index de065dc..5898c9d
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -4,7 +4,7 @@ LOCAL_PATH:= $(call my-dir)
 
 # --
 
-ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
+ifneq (,$(filter user userdebug eng,$(TARGET_BUILD_VARIANT)))
 init_options += -DALLOW_LOCAL_PROP_OVERRIDE=1 -DALLOW_DISABLE_SELINUX=1
 else
 init_options += -DALLOW_LOCAL_PROP_OVERRIDE=0 -DALLOW_DISABLE_SELINUX=0
@@ -49,6 +49,10 @@ LOCAL_SRC_FILES:= \
     ueventd_parser.cpp \
     watchdogd.cpp \
 
+ifneq ($(TARGET_IGNORE_RO_BOOT_REVISION),)
+LOCAL_CFLAGS += -DIGNORE_RO_BOOT_REVISION
+endif
+
 LOCAL_MODULE:= init
 LOCAL_C_INCLUDES += \
     system/extras/ext4_utils \
@@ -71,6 +75,9 @@ LOCAL_STATIC_LIBRARIES := \
     libc \
     libselinux \
     libmincrypt \
+    libext4_utils_static \
+    libext2_blkid \
+    libext2_uuid_static \
     libc++_static \
     libdl \
     libsparse_static \
diff --git a/init/init.cpp b/init/init.cpp
old mode 100644
new mode 100755
index 93fe944..0df8940
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -804,7 +804,9 @@ static void export_kernel_boot_props() {
         { "ro.boot.baseband",   "ro.baseband",   "unknown", },
         { "ro.boot.bootloader", "ro.bootloader", "unknown", },
         { "ro.boot.hardware",   "ro.hardware",   "unknown", },
+#ifndef IGNORE_RO_BOOT_REVISION
         { "ro.boot.revision",   "ro.revision",   "0", },
+#endif
     };
     for (size_t i = 0; i < ARRAY_SIZE(prop_map); i++) {
         char value[PROP_VALUE_MAX];
diff --git a/libcutils/iosched_policy.c b/libcutils/iosched_policy.c
old mode 100644
new mode 100755
index 8946d3c..745e2b6
--- a/libcutils/iosched_policy.c
+++ b/libcutils/iosched_policy.c
@@ -1,9 +1,10 @@
 /*
-** Copyright 2007, The Android Open Source Project
+** Copyright 2007-2014, The Android Open Source Project
+** Copyright 2015, The CyanogenMod Project
 **
-** Licensed under the Apache License, Version 2.0 (the "License"); 
-** you may not use this file except in compliance with the License. 
-** You may obtain a copy of the License at 
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
 **
 **     http://www.apache.org/licenses/LICENSE-2.0 
 **
@@ -20,28 +21,30 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <pthread.h>
 
 #include <cutils/iosched_policy.h>
+#define LOG_TAG "iosched_policy"
+#include <cutils/log.h>
+
+#define __android_unused __attribute__((__unused__))
 
 #ifdef HAVE_ANDROID_OS
 #include <linux/ioprio.h>
 #include <sys/syscall.h>
-#define __android_unused
-#else
-#define __android_unused __attribute__((__unused__))
-#endif
+#include <sys/stat.h>
+
+static int __rtio_cgroup_supported = -1;
+static pthread_once_t __rtio_init_once = PTHREAD_ONCE_INIT;
 
 int android_set_ioprio(int pid __android_unused, IoSchedClass clazz __android_unused, int ioprio __android_unused) {
-#ifdef HAVE_ANDROID_OS
     if (syscall(SYS_ioprio_set, IOPRIO_WHO_PROCESS, pid, ioprio | (clazz << IOPRIO_CLASS_SHIFT))) {
         return -1;
     }
-#endif
     return 0;
 }
 
 int android_get_ioprio(int pid __android_unused, IoSchedClass *clazz, int *ioprio) {
-#ifdef HAVE_ANDROID_OS
     int rc;
 
     if ((rc = syscall(SYS_ioprio_get, IOPRIO_WHO_PROCESS, pid)) < 0) {
@@ -50,9 +53,83 @@ int android_get_ioprio(int pid __android_unused, IoSchedClass *clazz, int *iopri
 
     *clazz = (rc >> IOPRIO_CLASS_SHIFT);
     *ioprio = (rc & 0xff);
+    return 0;
+}
+
+static void __initialize_rtio(void) {
+    if (!access("/sys/fs/cgroup/bfqio/tasks", W_OK) ||
+        !access("/sys/fs/cgroup/bfqio/rt-display/tasks", W_OK)) {
+        __rtio_cgroup_supported = 1;
+    } else {
+        __rtio_cgroup_supported = 0;
+    }
+}
+
+int android_set_rt_ioprio(int tid, int rt) {
+    int fd = -1, rc = -1;
+
+    pthread_once(&__rtio_init_once, __initialize_rtio);
+    if (__rtio_cgroup_supported != 1) {
+        return -1;
+    }
+
+    if (rt) {
+        fd = open("/sys/fs/cgroup/bfqio/rt-display/tasks", O_WRONLY | O_CLOEXEC);
+    } else {
+        fd = open("/sys/fs/cgroup/bfqio/tasks", O_WRONLY | O_CLOEXEC);
+    }
+
+    if (fd < 0) {
+        return -1;
+    }
+
+#ifdef HAVE_GETTID
+    if (tid == 0) {
+        tid = gettid();
+    }
+#endif
+
+    // specialized itoa -- works for tid > 0
+    char text[22];
+    char *end = text + sizeof(text) - 1;
+    char *ptr = end;
+    *ptr = '\0';
+    while (tid > 0) {
+        *--ptr = '0' + (tid % 10);
+        tid = tid / 10;
+    }
+
+    rc = write(fd, ptr, end - ptr);
+    if (rc < 0) {
+        /*
+         * If the thread is in the process of exiting,
+         * don't flag an error
+         */
+        if (errno == ESRCH) {
+            rc = 0;
+        } else {
+            SLOGV("android_set_rt_ioprio failed to write '%s' (%s); fd=%d\n",
+                  ptr, strerror(errno), fd);
+        }
+    }
+
+    close(fd);
+    return rc;
+}
+
 #else
+int android_set_ioprio(int pid __android_unused, IoSchedClass clazz __android_unused, int ioprio __android_unused) {
+    return 0;
+}
+
+int android_get_ioprio(int pid __android_unused, IoSchedClass *clazz, int *ioprio) {
     *clazz = IoSchedClass_NONE;
     *ioprio = 0;
-#endif
     return 0;
 }
+
+int android_set_rt_ioprio(int tid __android_unused, int rt __android_unused)
+{
+    return 0;
+}
+#endif
diff --git a/libutils/String8.cpp b/libutils/String8.cpp
old mode 100644
new mode 100755
index ad65fdb..3d95a87
--- a/libutils/String8.cpp
+++ b/libutils/String8.cpp
@@ -164,7 +164,9 @@ String8::String8(StaticLinkage)
 String8::String8(const String8& o)
     : mString(o.mString)
 {
-    SharedBuffer::bufferFromData(mString)->acquire();
+    if (mString == NULL)
+		mString = getEmptyString();
+	SharedBuffer::bufferFromData(mString)->acquire();
 }
 
 String8::String8(const char* o)
diff --git a/libutils/VectorImpl.cpp b/libutils/VectorImpl.cpp
old mode 100644
new mode 100755
index de65a6c..ffd552b
--- a/libutils/VectorImpl.cpp
+++ b/libutils/VectorImpl.cpp
@@ -552,6 +552,17 @@ void VectorImpl::_do_move_backward(void* dest, const void* from, size_t num) con
     do_move_backward(dest, from, num);
 }
 
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+void VectorImpl::reservedVectorImpl1() { }
+void VectorImpl::reservedVectorImpl2() { }
+void VectorImpl::reservedVectorImpl3() { }
+void VectorImpl::reservedVectorImpl4() { }
+void VectorImpl::reservedVectorImpl5() { }
+void VectorImpl::reservedVectorImpl6() { }
+void VectorImpl::reservedVectorImpl7() { }
+void VectorImpl::reservedVectorImpl8() { }
+#endif
+
 /*****************************************************************************/
 
 SortedVectorImpl::SortedVectorImpl(size_t itemSize, uint32_t flags)
@@ -667,6 +678,17 @@ ssize_t SortedVectorImpl::remove(const void* item)
     return i;
 }
 
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+void SortedVectorImpl::reservedSortedVectorImpl1() { };
+void SortedVectorImpl::reservedSortedVectorImpl2() { };
+void SortedVectorImpl::reservedSortedVectorImpl3() { };
+void SortedVectorImpl::reservedSortedVectorImpl4() { };
+void SortedVectorImpl::reservedSortedVectorImpl5() { };
+void SortedVectorImpl::reservedSortedVectorImpl6() { };
+void SortedVectorImpl::reservedSortedVectorImpl7() { };
+void SortedVectorImpl::reservedSortedVectorImpl8() { };
+#endif
+
 /*****************************************************************************/
 
 }; // namespace android
diff --git a/sdcard/sdcard.c b/sdcard/sdcard.c
old mode 100644
new mode 100755
index a79e2dd..b6e0b49
--- a/sdcard/sdcard.c
+++ b/sdcard/sdcard.c
@@ -1756,7 +1756,7 @@ static int fuse_setup(struct fuse* fuse, gid_t gid, mode_t mask) {
             fuse->fd, fuse->global->uid, fuse->global->gid);
     if (mount("/dev/fuse", fuse->dest_path, "fuse", MS_NOSUID | MS_NODEV | MS_NOEXEC |
             MS_NOATIME, opts) != 0) {
-        ERROR("failed to mount fuse filesystem: %s\n", strerror(errno));
+        ERROR("failed to mount fuse filesystem: %s: %s\n", fuse->dest_path, strerror(errno));
         return -1;
     }
 
