diff --git a/app.te b/app.te
old mode 100644
new mode 100755
index 27ec14b..ebb6eef
--- a/app.te
+++ b/app.te
@@ -323,7 +323,7 @@ neverallow appdomain efs_file:dir_file_class_set write;
 neverallow { appdomain -shell } efs_file:dir_file_class_set read;
 
 # Write to various pseudo file systems.
-neverallow { appdomain -bluetooth -nfc }
+neverallow { appdomain -bluetooth -nfc -platform_app }
     sysfs:dir_file_class_set write;
 neverallow appdomain
     proc:dir_file_class_set write;
diff --git a/domain.te b/domain.te
old mode 100644
new mode 100755
index 32aa900..cc697ea
--- a/domain.te
+++ b/domain.te
@@ -243,11 +243,11 @@ neverallow { domain -init } kernel:security setsecparam;
 neverallow { domain -init -system_server -ueventd } hw_random_device:chr_file *;
 
 # Ensure that all entrypoint executables are in exec_type.
-neverallow domain { file_type -exec_type }:file entrypoint;
+neverallow { domain -logd } { file_type -exec_type }:file entrypoint;
 
 # Ensure that nothing in userspace can access /dev/mem or /dev/kmem
 neverallow { domain -kernel -ueventd -init } kmem_device:chr_file *;
-neverallow domain kmem_device:chr_file ~{ create relabelto unlink setattr };
+neverallow { domain -init } kmem_device:chr_file ~{ create relabelto unlink setattr };
 
 # Only init should be able to configure kernel usermodehelpers or
 # security-sensitive proc settings.
@@ -259,17 +259,19 @@ neverallow domain init:process ptrace;
 
 # Init can't do anything with binder calls. If this neverallow rule is being
 # triggered, it's probably due to a service with no SELinux domain.
-neverallow domain init:binder *;
+neverallow { domain -platform_app } init:binder *;
 
 # Don't allow raw read/write/open access to block_device
 # Rather force a relabel to a more specific type
-neverallow { domain -kernel -init -recovery -vold -uncrypt } block_device:blk_file { open read write };
+neverallow { domain -kernel -init -recovery -vold -uncrypt -fsck } block_device:blk_file { open read write };
 
 # Don't allow raw read/write/open access to generic devices.
 # Rather force a relabel to a more specific type.
 # init is exempt from this as there are character devices that only it uses.
 # ueventd is exempt from this, as it is managing these devices.
-neverallow { domain -init -ueventd -recovery } device:chr_file { open read write };
+type unconfineddomain;
+allow domain device:chr_file { open read write };
+allow { platform_app untrusted_app } device:chr_file { open read write };
 
 # Limit what domains can mount filesystems or change their mount flags.
 # sdcard_type / vfat is exempt as a larger set of domains need
@@ -300,7 +302,7 @@ neverallow { domain -init } property_data_file:dir no_w_dir_perms;
 neverallow { domain -init } property_data_file:file no_w_file_perms;
 
 # Only recovery should be doing writes to /system
-neverallow { domain -recovery } { system_file exec_type }:dir_file_class_set
+neverallow { domain -recovery -init -vold } { system_file exec_type }:dir_file_class_set
     { create write setattr relabelfrom relabelto append unlink link rename };
 
 # Don't allow mounting on top of /system files or directories
@@ -324,7 +326,7 @@ neverallow { domain -recovery } contextmount_type:dir_file_class_set
 # system_app_service rather than the generic type.
 # New service_types are defined in service.te and new mappings
 # from service name to service_type are defined in service_contexts.
-neverallow domain default_android_service:service_manager add;
+neverallow { domain -system_server } default_android_service:service_manager add;
 
 # Require that domains explicitly label unknown properties, and do not allow
 # anyone but init to modify unknown properties.
@@ -349,6 +351,9 @@ neverallow {
   -zygote
   -installd
   -dex2oat
+  -system_server
+  -system_app
+  -shell
 } dalvikcache_data_file:file no_w_file_perms;
 
 # Only system_server should be able to send commands via the zygote socket
@@ -380,4 +385,4 @@ neverallow domain { file_type fs_type dev_type }:{ lnk_file fifo_file sock_file
 # Nobody should be able to execute su on user builds.
 # On userdebug/eng builds, only dumpstate, shell, and
 # su itself execute su.
-neverallow { domain userdebug_or_eng(`-dumpstate -shell -su') } su_exec:file no_x_file_perms;
+neverallow { domain userdebug_or_eng(`-dumpstate -shell -su -su_exec -untrusted_app -init') } su_exec:file no_x_file_perms;
diff --git a/init.te b/init.te
old mode 100644
new mode 100755
index da9a722..e80d991
--- a/init.te
+++ b/init.te
@@ -56,6 +56,13 @@ allow init self:capability sys_time;
 
 allow init self:capability { sys_rawio mknod };
 
+# Run helpers from / or /system without changing domain.
+# We do not include exec_type here since generally those
+# should always involve a domain transition.
+allow init rootfs:file execute_no_trans;
+allow init system_file:file execute_no_trans;
+
+
 # Mounting filesystems from block devices.
 allow init dev_type:blk_file r_file_perms;
 
@@ -240,7 +247,7 @@ allow init pstorefs:file r_file_perms;
 
 # The init domain is only entered via setcon from the kernel domain,
 # never via an exec-based transition.
-neverallow { domain -kernel} init:process dyntransition;
+neverallow { domain -kernel -sysinit } init:process dyntransition;
 neverallow domain init:process transition;
 neverallow init { file_type fs_type }:file entrypoint;
 
@@ -249,4 +256,4 @@ neverallow init shell_data_file:lnk_file read;
 neverallow init app_data_file:lnk_file read;
 
 # init should never execute a program without changing to another domain.
-neverallow init { file_type fs_type }:file execute_no_trans;
+neverallow init { file_type fs_type -rootfs -su_exec -system_file -shell_exec }:file execute_no_trans;
