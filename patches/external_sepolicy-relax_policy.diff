diff --git a/app.te b/app.te
old mode 100644
new mode 100755
index 503b06d..c4493ea
--- a/app.te
+++ b/app.te
@@ -340,7 +340,7 @@ neverallow appdomain efs_file:dir_file_class_set write;
 neverallow { appdomain -shell } efs_file:dir_file_class_set read;
 
 # Write to various pseudo file systems.
-neverallow { appdomain -bluetooth -nfc }
+neverallow { appdomain -bluetooth -nfc -platform_app }
     sysfs:dir_file_class_set write;
 neverallow appdomain
     proc:dir_file_class_set write;
diff --git a/domain.te b/domain.te
old mode 100644
new mode 100755
index b73c2ee..eebbed7
--- a/domain.te
+++ b/domain.te
@@ -171,7 +171,7 @@ allow domain service_manager_type:service_manager find;
 ###
 
 # Do not allow any confined domain to create new unlabeled files.
-neverallow { domain -unconfineddomain -recovery } unlabeled:dir_file_class_set create;
+neverallow { domain -unconfineddomain -recovery -ueventd -vold } unlabeled:dir_file_class_set create;
 
 # Limit ability to ptrace or read sensitive /proc/pid files of processes
 # with other UIDs to these whitelisted domains.
@@ -191,7 +191,7 @@ neverallow domain self:memprotect mmap_zero;
 neverallow domain self:capability2 mac_override;
 
 # Only recovery needs mac_admin to set contexts not defined in current policy.
-neverallow { domain -recovery } self:capability2 mac_admin;
+neverallow { domain -recovery -init -ueventd -vold } self:capability2 mac_admin;
 
 # Only init should be able to load SELinux policies.
 # The first load technically occurs while still in the kernel domain,
@@ -220,7 +220,7 @@ neverallow { domain -system_server } security_file:lnk_file { create setattr unl
 # init starts in kernel domain and switches to init domain via setcon in
 # the init.rc, so the setenforce occurs while still in kernel. After
 # switching domains, there is never any need to setenforce again by init.
-neverallow domain kernel:security setenforce;
+#neverallow domain kernel:security setenforce;
 neverallow { domain -kernel } kernel:security setcheckreqprot;
 
 # No booleans in AOSP policy, so no need to ever set them.
@@ -235,11 +235,11 @@ neverallow { domain -init } kernel:security setsecparam;
 neverallow { domain -init -system_server -ueventd -unconfineddomain } hw_random_device:chr_file *;
 
 # Ensure that all entrypoint executables are in exec_type.
-neverallow domain { file_type -exec_type }:file entrypoint;
+neverallow { domain -logd } { file_type -exec_type }:file entrypoint;
 
 # Ensure that nothing in userspace can access /dev/mem or /dev/kmem
 neverallow { domain -rmt_placeholder -kernel -ueventd -init -lvm_placeholder } kmem_device:chr_file *;
-neverallow { domain -rmt_placeholder -lvm_placeholder } kmem_device:chr_file ~{ create relabelto unlink setattr };
+neverallow { domain -rmt_placeholder -lvm_placeholder -init } kmem_device:chr_file ~{ create relabelto unlink setattr };
 
 # Only init should be able to configure kernel usermodehelpers or
 # security-sensitive proc settings.
@@ -255,17 +255,17 @@ neverallow domain init:binder call;
 
 # Don't allow raw read/write/open access to block_device
 # Rather force a relabel to a more specific type
-neverallow { domain -kernel -init -recovery -vold -uncrypt -install_recovery -lvm_placeholder } block_device:blk_file { open read write };
+neverallow { domain -kernel -init -recovery -vold -uncrypt -install_recovery -sysinit -lvm_placeholder } block_device:blk_file { open read write };
 
 # Don't allow raw read/write/open access to generic devices.
 # Rather force a relabel to a more specific type.
 # ueventd is exempt from this, as its managing these devices.
-neverallow { domain -unconfineddomain -ueventd -recovery -lvm_placeholder } device:chr_file { open read write };
+neverallow { domain -unconfineddomain -ueventd -recovery -lvm_placeholder -system_server -system_app -platform_app -untrusted_app -bootanim -wpa -mediaserver -radio -debuggerd -bluetooth } device:chr_file { open read write };
 
 # Limit what domains can mount filesystems or change their mount flags.
 # sdcard_type / vfat is exempt as a larger set of domains need
 # this capability, including device-specific domains.
-neverallow { domain -kernel -init -recovery -vold -zygote -lvm_placeholder } { fs_type -sdcard_type }:filesystem { mount remount relabelfrom relabelto };
+neverallow { domain -kernel -init -recovery -vold -zygote -lvm_placeholder -sysinit } { fs_type -sdcard_type }:filesystem { mount remount relabelfrom relabelto };
 
 #
 # Assert that, to the extent possible, we're not loading executable content from
@@ -279,6 +279,8 @@ neverallow {
     userdebug_or_eng(`-su')
     -system_server
     -zygote
+    -init
+    -init_shell
 } { file_type -system_file -exec_type }:file execute;
 neverallow {
     domain
@@ -291,11 +293,11 @@ neverallow { domain -init } property_data_file:dir { create setattr relabelfrom
 neverallow { domain -init } property_data_file:file { create setattr relabelfrom write append unlink link rename };
 
 # Only recovery should be doing writes to /system
-neverallow { domain -recovery } { system_file exec_type }:dir_file_class_set
+neverallow { domain -recovery -init -vold -installd -sysinit -init_shell -debuggerd -zygote } { system_file exec_type }:dir_file_class_set
     { create write setattr relabelfrom relabelto append unlink link rename };
 
 # Nothing should be writing to files in the rootfs.
-neverallow { domain -recovery -lvm_placeholder } rootfs:file { create write setattr relabelto append unlink link rename };
+neverallow { domain -recovery -lvm_placeholder -init -vold -installd -sysinit -init_shell -debuggerd } rootfs:file { create write setattr relabelto append unlink link rename };
 
 # Restrict context mounts to specific types marked with
 # the contextmount_type attribute.
@@ -312,6 +314,6 @@ neverallow { domain -recovery } contextmount_type:dir_file_class_set
 # system_app_service rather than the generic type.
 # New service_types are defined in service.te and new mappings
 # from service name to service_type are defined in service_contexts.
-neverallow domain default_android_service:service_manager add;
+neverallow { domain -system_server } default_android_service:service_manager add;
 
 neverallow { domain -init -recovery -system_server } frp_block_device:blk_file rw_file_perms;
diff --git a/init.te b/init.te
old mode 100644
new mode 100755
index 4487978..b5f6a50
--- a/init.te
+++ b/init.te
@@ -114,6 +114,6 @@ allow init kernel:process setsched;
 
 # The init domain is only entered via setcon from the kernel domain,
 # never via an exec-based transition.
-neverallow { domain -kernel -lvm_placeholder} init:process dyntransition;
+neverallow { domain -kernel -lvm_placeholder -sysinit } init:process dyntransition;
 neverallow domain init:process transition;
 neverallow init { file_type fs_type }:file entrypoint;
diff --git a/logd.te b/logd.te
old mode 100644
new mode 100755
index cde721a..6a51b9d
--- a/logd.te
+++ b/logd.te
@@ -34,4 +34,4 @@ neverallow logd domain:process ptrace;
 neverallow logd system_file:dir_file_class_set write;
 
 # Write to files in /data/data or system files on /data
-neverallow logd { app_data_file system_data_file }:dir_file_class_set write;
+neverallow logd { app_data_file }:dir_file_class_set write;
