diff --git a/cmds/bootanimation/Android.mk b/cmds/bootanimation/Android.mk
old mode 100644
new mode 100755
index 719fd7d..0d82b4c
--- a/cmds/bootanimation/Android.mk
+++ b/cmds/bootanimation/Android.mk
@@ -29,6 +29,18 @@ ifeq ($(TARGET_CONTINUOUS_SPLASH_ENABLED),true)
     LOCAL_CFLAGS += -DCONTINUOUS_SPLASH
 endif
 
+ifeq ($(TARGET_BOOTANIMATION_PRELOAD),true)
+    LOCAL_CFLAGS += -DPRELOAD_BOOTANIMATION
+endif
+
+ifeq ($(TARGET_BOOTANIMATION_TEXTURE_CACHE),true)
+    LOCAL_CFLAGS += -DNO_TEXTURE_CACHE=0
+endif
+
+ifeq ($(TARGET_BOOTANIMATION_TEXTURE_CACHE),false)
+    LOCAL_CFLAGS += -DNO_TEXTURE_CACHE=1
+endif
+
 ifeq ($(TARGET_BOOTANIMATION_USE_RGB565),true)
     LOCAL_CFLAGS += -DUSE_565
 endif
diff --git a/cmds/bootanimation/BootAnimation.cpp b/cmds/bootanimation/BootAnimation.cpp
old mode 100644
new mode 100755
index 18ad5c4..4e447b7
--- a/cmds/bootanimation/BootAnimation.cpp
+++ b/cmds/bootanimation/BootAnimation.cpp
@@ -137,6 +137,57 @@ static void setPowerHint(int durationMs) {
     }
 }
 
+static long getFreeMemory(void)
+{
+    int fd = open("/proc/meminfo", O_RDONLY);
+    const char* const sums[] = { "MemFree:", "Cached:", NULL };
+    const int sumsLen[] = { strlen("MemFree:"), strlen("Cached:"), 0 };
+    int num = 2;
+
+    if (fd < 0) {
+        ALOGW("Unable to open /proc/meminfo");
+        return -1;
+    }
+
+    char buffer[256];
+    const int len = read(fd, buffer, sizeof(buffer)-1);
+    close(fd);
+
+    if (len < 0) {
+        ALOGW("Unable to read /proc/meminfo");
+        return -1;
+    }
+    buffer[len] = 0;
+
+    size_t numFound = 0;
+    long mem = 0;
+
+    char* p = buffer;
+    while (*p && numFound < num) {
+        int i = 0;
+        while (sums[i]) {
+            if (strncmp(p, sums[i], sumsLen[i]) == 0) {
+                p += sumsLen[i];
+                while (*p == ' ') p++;
+                char* num = p;
+                while (*p >= '0' && *p <= '9') p++;
+                if (*p != 0) {
+                    *p = 0;
+                    p++;
+                    if (*p == 0) p--;
+                }
+                mem += atoll(num);
+                numFound++;
+                break;
+            }
+            i++;
+        }
+        p++;
+    }
+
+    return numFound > 0 ? mem : -1;
+}
+
 BootAnimation::BootAnimation() : Thread(false), mZip(NULL)
 {
     mSession = new SurfaceComposerClient();
@@ -387,6 +438,7 @@ status_t BootAnimation::readyToRun() {
         mZip = zipFile;
     }
 
+#ifdef PRELOAD_BOOTANIMATION
     // Preload the bootanimation zip on memory, so we don't stutter
     // when showing the animation
     FILE* fd;
@@ -415,6 +467,7 @@ status_t BootAnimation::readyToRun() {
         }
         fclose(fd);
     }
+#endif
 
     return NO_ERROR;
 }
@@ -710,6 +763,35 @@ bool BootAnimation::movie()
         const Animation::Part& part(animation.parts[i]);
         const size_t fcount = part.frames.size();
 
+        // can be 1, 0, or not set
+        #ifdef NO_TEXTURE_CACHE
+        const int noTextureCache = NO_TEXTURE_CACHE;
+        #else
+        const int noTextureCache =
+                ((animation.width * animation.height * fcount) > 48 * 1024 * 1024) ? 1 : 0;
+        #endif
+
+        glBindTexture(GL_TEXTURE_2D, 0);
+
+        /*calculate if we need to runtime save memory
+        * condition: runtime free memory is less than the textures that will used.
+        * needSaveMem default to be false
+        */
+        GLint mMaxTextureSize;
+        bool needSaveMem = false;
+        GLuint mTextureid;
+        glGetIntegerv(GL_MAX_TEXTURE_SIZE, &mMaxTextureSize);
+        //ALOGD("freemem:%ld, %d", getFreeMemory(), mMaxTextureSize);
+        if(getFreeMemory() < mMaxTextureSize * mMaxTextureSize * fcount / 1024 || noTextureCache) {
+            ALOGD("Use save memory method, maybe small fps in actual.");
+            needSaveMem = true;
+            glGenTextures(1, &mTextureid);
+            glBindTexture(GL_TEXTURE_2D, mTextureid);
+            glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+            glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+        }
+
         setPowerHint(frameDuration * 1000 * fcount);
 
         for (int r=0 ; !part.count || r<part.count ; r++) {
