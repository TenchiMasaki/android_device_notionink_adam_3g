diff --git a/include/binder/MemoryDealer.h b/include/binder/MemoryDealer.h
old mode 100644
new mode 100755
index aa415d5..e314762
--- a/include/binder/MemoryDealer.h
+++ b/include/binder/MemoryDealer.h
@@ -34,8 +34,8 @@ class SimpleBestFitAllocator;
 class MemoryDealer : public RefBase
 {
 public:
-    MemoryDealer(size_t size, const char* name = 0,
-            uint32_t flags = 0 /* or bits such as MemoryHeapBase::READ_ONLY */ );
+    MemoryDealer(size_t size, const char* name = 0);
+    MemoryDealer(size_t size, const char* name , uint32_t flags  /* or bits such as MemoryHeapBase::READ_ONLY */ );
 
     virtual sp<IMemory> allocate(size_t size);
     virtual void        deallocate(size_t offset);
diff --git a/include/gui/SurfaceComposerClient.h b/include/gui/SurfaceComposerClient.h
old mode 100644
new mode 100755
index 9ec3f23..ade00f2
--- a/include/gui/SurfaceComposerClient.h
+++ b/include/gui/SurfaceComposerClient.h
@@ -85,9 +85,20 @@ public:
     /* Triggers screen on/off or low power mode and waits for it to complete */
     static void setDisplayPowerMode(const sp<IBinder>& display, int mode);
 
+	static status_t getDisplayInfo(int32_t displayId, DisplayInfo* info);
+
     // ------------------------------------------------------------------------
     // surface creation / destruction
 
+ 
+	sp<SurfaceControl> createSurface(
+        uint32_t display,
+        uint32_t w,
+        uint32_t h,
+        PixelFormat format,
+        uint32_t flags);
+
+
     //! Create a surface
     sp<SurfaceControl> createSurface(
             const String8& name,// name of the surface
diff --git a/include/gui/SurfaceControl.h b/include/gui/SurfaceControl.h
old mode 100644
new mode 100755
index 5fa45d1..3edb58f
--- a/include/gui/SurfaceControl.h
+++ b/include/gui/SurfaceControl.h
@@ -60,6 +60,7 @@ public:
     status_t    setLayerStack(uint32_t layerStack);
     status_t    setLayer(uint32_t layer);
     status_t    setPosition(float x, float y);
+	status_t 	setPosition(int32_t x, int32_t y);
     status_t    setSize(uint32_t w, uint32_t h);
     status_t    hide();
     status_t    show();
diff --git a/include/ui/PixelFormat.h b/include/ui/PixelFormat.h
old mode 100644
new mode 100755
index f26fecb..2070ffb
--- a/include/ui/PixelFormat.h
+++ b/include/ui/PixelFormat.h
@@ -25,6 +25,9 @@
 #ifndef UI_PIXELFORMAT_H
 #define UI_PIXELFORMAT_H
 
+#include <stdint.h>
+#include <sys/types.h>
+#include <utils/Errors.h>
 #include <hardware/hardware.h>
 
 namespace android {
@@ -64,6 +67,59 @@ enum {
 
 typedef int32_t PixelFormat;
 
+#ifdef HAVE_PIXEL_FORMAT_INFO
+struct PixelFormatInfo {
+    enum {
+        INDEX_ALPHA   = 0,
+        INDEX_RED     = 1,
+        INDEX_GREEN   = 2,
+        INDEX_BLUE    = 3
+    };
+
+    enum { // components
+        ALPHA   = 1,
+        RGB     = 2,
+        RGBA    = 3,
+        L       = 4,
+        LA      = 5,
+        OTHER   = 0xFF
+    };
+
+    struct szinfo {
+        uint8_t h;
+        uint8_t l;
+    };
+
+    inline PixelFormatInfo() : version(sizeof(PixelFormatInfo)) { }
+    size_t getScanlineSize(unsigned int width) const;
+    size_t getSize(size_t ci) const {
+        return (ci <= 3) ? (cinfo[ci].h - cinfo[ci].l) : 0;
+    }
+    size_t      version;
+    PixelFormat format;
+    size_t      bytesPerPixel;
+    size_t      bitsPerPixel;
+    union {
+        szinfo      cinfo[4];
+        struct {
+            uint8_t     h_alpha;
+            uint8_t     l_alpha;
+            uint8_t     h_red;
+            uint8_t     l_red;
+            uint8_t     h_green;
+            uint8_t     l_green;
+            uint8_t     h_blue;
+            uint8_t     l_blue;
+        };
+    };
+    uint8_t     components;
+    uint8_t     reserved0[3];
+    uint32_t    reserved1;
+};
+
+status_t getPixelFormatInfo(PixelFormat format, PixelFormatInfo* info);
+#endif
+
 uint32_t bytesPerPixel(PixelFormat format);
 uint32_t bitsPerPixel(PixelFormat format);
 
diff --git a/libs/binder/MemoryDealer.cpp b/libs/binder/MemoryDealer.cpp
old mode 100644
new mode 100755
index 8739625..d6e359d
--- a/libs/binder/MemoryDealer.cpp
+++ b/libs/binder/MemoryDealer.cpp
@@ -231,6 +231,14 @@ MemoryDealer::MemoryDealer(size_t size, const char* name, uint32_t flags)
 {    
 }
 
+MemoryDealer::MemoryDealer(size_t size, const char* name)
+    : mHeap(new MemoryHeapBase(size, 0, name)),
+    mAllocator(new SimpleBestFitAllocator(size))
+{
+}
+
+
+
 MemoryDealer::~MemoryDealer()
 {
     delete mAllocator;
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
old mode 100644
new mode 100755
index 76aec6e..af7097c
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -95,6 +95,10 @@ ifeq ($(TARGET_NO_SENSOR_PERMISSION_CHECK),true)
 LOCAL_CPPFLAGS += -DNO_SENSOR_PERMISSION_CHECK
 endif
 
+ifeq ($(SENSORS_NEED_SETRATE_ON_ENABLE), true)
+        LOCAL_CFLAGS += -DSENSORS_SETRATE_ON_ENABLE
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 
 ifeq (,$(ONE_SHOT_MAKEFILE))
diff --git a/libs/gui/SensorEventQueue.cpp b/libs/gui/SensorEventQueue.cpp
old mode 100644
new mode 100755
index 4b7986e..6bfe6f3
--- a/libs/gui/SensorEventQueue.cpp
+++ b/libs/gui/SensorEventQueue.cpp
@@ -134,8 +134,14 @@ status_t SensorEventQueue::disableSensor(Sensor const* sensor) const {
 
 status_t SensorEventQueue::enableSensor(int32_t handle, int32_t samplingPeriodUs,
                                         int maxBatchReportLatencyUs, int reservedFlags) const {
-    return mSensorEventConnection->enableDisable(handle, true, us2ns(samplingPeriodUs),
+    status_t err = mSensorEventConnection->enableDisable(handle, true, us2ns(samplingPeriodUs),
                                                  us2ns(maxBatchReportLatencyUs), reservedFlags);
+    #ifdef SENSORS_SETRATE_ON_ENABLE
+    if (err == NO_ERROR) {
+        mSensorEventConnection->setEventRate(handle, us2ns(samplingPeriodUs));
+    }
+    #endif
+    return err;
 }
 
 status_t SensorEventQueue::flush() const {
diff --git a/libs/gui/SurfaceComposerClient.cpp b/libs/gui/SurfaceComposerClient.cpp
old mode 100644
new mode 100755
index 82bdd6b..452e22c
--- a/libs/gui/SurfaceComposerClient.cpp
+++ b/libs/gui/SurfaceComposerClient.cpp
@@ -534,6 +534,25 @@ void SurfaceComposerClient::dispose() {
     mStatus = NO_INIT;
 }
 
+/* Create ICS/MR0-compatible constructors */
+sp<SurfaceControl> SurfaceComposerClient::createSurface(
+        uint32_t display,
+        uint32_t w,
+        uint32_t h,
+        PixelFormat format,
+        uint32_t flags)
+{
+    String8 name;
+    const size_t SIZE = 128;
+    char buffer[SIZE];
+	uint32_t d;
+	d = display;
+    snprintf(buffer, SIZE, "<pid_%d>", getpid());
+    name.append(buffer);
+
+    return SurfaceComposerClient::createSurface(name, w, h, format, flags);
+}
+
 sp<SurfaceControl> SurfaceComposerClient::createSurface(
         const String8& name,
         uint32_t w,
@@ -718,6 +737,7 @@ status_t SurfaceComposerClient::getDisplayInfo(const sp<IBinder>& display,
         return result;
     }
 
+
     int activeId = getActiveConfig(display);
     if (activeId < 0) {
         ALOGE("No active configuration found");
@@ -728,6 +748,13 @@ status_t SurfaceComposerClient::getDisplayInfo(const sp<IBinder>& display,
     return NO_ERROR;
 }
 
+status_t SurfaceComposerClient::getDisplayInfo( int32_t displayId, DisplayInfo* info)
+{
+    return getDisplayInfo(getBuiltInDisplay(displayId), info);
+}
+
+// ----------------------------------------------------------------------------
+
 int SurfaceComposerClient::getActiveConfig(const sp<IBinder>& display) {
     return ComposerService::getComposerService()->getActiveConfig(display);
 }
diff --git a/libs/gui/SurfaceControl.cpp b/libs/gui/SurfaceControl.cpp
old mode 100644
new mode 100755
index 8212b90..2aa040f
--- a/libs/gui/SurfaceControl.cpp
+++ b/libs/gui/SurfaceControl.cpp
@@ -124,6 +124,11 @@ status_t SurfaceControl::setPosition(float x, float y) {
     if (err < 0) return err;
     return mClient->setPosition(mHandle, x, y);
 }
+
+status_t SurfaceControl::setPosition(int32_t x, int32_t y) {
+    return SurfaceControl::setPosition(static_cast<float>(x), static_cast<float>(y));
+}
+
 status_t SurfaceControl::setSize(uint32_t w, uint32_t h) {
     status_t err = validate();
     if (err < 0) return err;
diff --git a/libs/ui/Android.mk b/libs/ui/Android.mk
old mode 100644
new mode 100755
index a8eb67b..04f14d9
--- a/libs/ui/Android.mk
+++ b/libs/ui/Android.mk
@@ -60,7 +60,11 @@ ifeq ($(BOARD_EGL_NEEDS_HANDLE_VALUE),true)
 LOCAL_CFLAGS += -DEGL_NEEDS_HANDLE
 endif
 
-LOCAL_MODULE := libui
+ifeq ($(BOARD_HAVE_PIXEL_FORMAT_INFO),true)
+LOCAL_CFLAGS += -DHAVE_PIXEL_FORMAT_INFO
+endif
+
+LOCAL_MODULE:= libui
 
 include $(BUILD_SHARED_LIBRARY)
 
diff --git a/libs/ui/PixelFormat.cpp b/libs/ui/PixelFormat.cpp
old mode 100644
new mode 100755
index cab1dde..f930430
--- a/libs/ui/PixelFormat.cpp
+++ b/libs/ui/PixelFormat.cpp
@@ -20,6 +20,113 @@
 namespace android {
 // ----------------------------------------------------------------------------
 
+#ifdef HAVE_PIXEL_FORMAT_INFOx
+static const int COMPONENT_YUV = 0xFF;
+
+struct Info {
+    size_t      size;
+    uint32_t      bitsPerPixel;
+    struct {
+        uint8_t     ah;
+        uint8_t     al;
+        uint8_t     rh;
+        uint8_t     rl;
+        uint8_t     gh;
+        uint8_t     gl;
+        uint8_t     bh;
+        uint8_t     bl;
+    };
+    uint8_t     components;
+};
+
+static Info const sPixelFormatInfos[] = {
+        { 0,  0, { 0, 0,   0, 0,   0, 0,   0, 0 }, 0 },
+        { 4, 32, {32,24,   8, 0,  16, 8,  24,16 }, PixelFormatInfo::RGBA },
+        { 4, 24, { 0, 0,   8, 0,  16, 8,  24,16 }, PixelFormatInfo::RGB  },
+        { 3, 24, { 0, 0,   8, 0,  16, 8,  24,16 }, PixelFormatInfo::RGB  },
+        { 2, 16, { 0, 0,  16,11,  11, 5,   5, 0 }, PixelFormatInfo::RGB  },
+        { 4, 32, {32,24,  24,16,  16, 8,   8, 0 }, PixelFormatInfo::RGBA },
+        { 2, 16, { 1, 0,  16,11,  11, 6,   6, 1 }, PixelFormatInfo::RGBA },
+        { 2, 16, { 4, 0,  16,12,  12, 8,   8, 4 }, PixelFormatInfo::RGBA },
+        { 1,  8, { 8, 0,   0, 0,   0, 0,   0, 0 }, PixelFormatInfo::ALPHA},
+        { 1,  8, { 0, 0,   8, 0,   8, 0,   8, 0 }, PixelFormatInfo::L    },
+        { 2, 16, {16, 8,   8, 0,   8, 0,   8, 0 }, PixelFormatInfo::LA   },
+        { 1,  8, { 0, 0,   8, 5,   5, 2,   2, 0 }, PixelFormatInfo::RGB  },
+};
+
+static const Info* gGetPixelFormatTable(size_t* numEntries) {
+    if (numEntries) {
+        *numEntries = sizeof(sPixelFormatInfos)/sizeof(Info);
+    }
+    return sPixelFormatInfos;
+}
+
+// ----------------------------------------------------------------------------
+
+size_t PixelFormatInfo::getScanlineSize(unsigned int width) const
+{
+    size_t size;
+    if (components == COMPONENT_YUV) {
+        // YCbCr formats are different.
+        size = (width * bitsPerPixel)>>3;
+    } else {
+        size = width * bytesPerPixel;
+    }
+    return size;
+}
+
+status_t getPixelFormatInfo(PixelFormat format, PixelFormatInfo* info)
+{
+    if (format <= 0)
+        return BAD_VALUE;
+
+    if (info->version != sizeof(PixelFormatInfo))
+        return INVALID_OPERATION;
+
+    // YUV format from the HAL are handled here
+    switch (format) {
+    case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_422_I:
+        info->bitsPerPixel = 16;
+        goto done;
+    case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+    case HAL_PIXEL_FORMAT_YV12:
+        info->bitsPerPixel = 12;
+     done:
+        info->format = format;
+        info->components = COMPONENT_YUV;
+        info->bytesPerPixel = 1;
+        info->h_alpha = 0;
+        info->l_alpha = 0;
+        info->h_red = info->h_green = info->h_blue = 8;
+        info->l_red = info->l_green = info->l_blue = 0;
+        return NO_ERROR;
+    }
+
+    size_t numEntries;
+    const Info *i = gGetPixelFormatTable(&numEntries) + format;
+    bool valid = uint32_t(format) < numEntries;
+    if (!valid) {
+        return BAD_INDEX;
+    }
+
+    info->format = format;
+    info->bytesPerPixel = i->size;
+    info->bitsPerPixel  = i->bitsPerPixel;
+    info->h_alpha       = i->ah;
+    info->l_alpha       = i->al;
+    info->h_red         = i->rh;
+    info->l_red         = i->rl;
+    info->h_green       = i->gh;
+    info->l_green       = i->gl;
+    info->h_blue        = i->bh;
+    info->l_blue        = i->bl;
+    info->components    = i->components;
+
+    return NO_ERROR;
+}
+#endif
+
 uint32_t bytesPerPixel(PixelFormat format) {
     switch (format) {
         case PIXEL_FORMAT_RGBA_8888:
diff --git a/libs/ui/tests/Android.mk b/libs/ui/tests/Android.mk
deleted file mode 100644
index 6438b1f..0000000
--- a/libs/ui/tests/Android.mk
+++ /dev/null
@@ -1,36 +0,0 @@
-#
-# Copyright (C) 2014 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(LOCAL_PATH)/Android.mk
-LOCAL_SHARED_LIBRARIES := libui
-LOCAL_SRC_FILES := Region_test.cpp
-LOCAL_MODULE := Region_test
-include $(BUILD_NATIVE_TEST)
-
-include $(CLEAR_VARS)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(LOCAL_PATH)/Android.mk
-LOCAL_SRC_FILES := vec_test.cpp
-LOCAL_MODULE := vec_test
-include $(BUILD_NATIVE_TEST)
-
-include $(CLEAR_VARS)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(LOCAL_PATH)/Android.mk
-LOCAL_SRC_FILES := mat_test.cpp
-LOCAL_MODULE := mat_test
-include $(BUILD_NATIVE_TEST)
diff --git a/opengl/libs/EGL/egl_object.cpp b/opengl/libs/EGL/egl_object.cpp
index 918faa8..f0a7f1d 100644
--- a/opengl/libs/EGL/egl_object.cpp
+++ b/opengl/libs/EGL/egl_object.cpp
@@ -110,7 +110,9 @@ void egl_context_t::onMakeCurrent(EGLSurface draw, EGLSurface read) {
     if (gl_extensions.isEmpty()) {
         // call the implementation's glGetString(GL_EXTENSIONS)
         const char* exts = (const char *)gEGLImpl.hooks[version]->gl.glGetString(GL_EXTENSIONS);
-        gl_extensions.setTo(exts);
+        if (exts != NULL) {
+            gl_extensions.setTo(exts);
+        }
         if (gl_extensions.find("GL_EXT_debug_marker") < 0) {
             String8 temp("GL_EXT_debug_marker ");
             temp.append(gl_extensions);
diff --git a/services/sensorservice/SensorService.cpp b/services/sensorservice/SensorService.cpp
old mode 100644
new mode 100755
index fd72b23..36e27ec
--- a/services/sensorservice/SensorService.cpp
+++ b/services/sensorservice/SensorService.cpp
@@ -146,9 +146,10 @@ void SensorService::onFirstRef()
 
                 aSensor = registerVirtualSensor( new OrientationSensor() );
                 if (virtualSensorsNeeds & (1<<SENSOR_TYPE_ROTATION_VECTOR)) {
-                    // if we are doing our own rotation-vector, also add
-                    // the orientation sensor and remove the HAL provided one.
-                    mUserSensorList.replaceAt(aSensor, orientationIndex);
+                    if (orientationIndex == -1) {
+                        // some sensor HALs don't provide an orientation sensor.
+                        mUserSensorList.add(aSensor);
+                    }
                 }
 
                 // virtual debugging sensors are not added to mUserSensorList
@@ -918,20 +919,24 @@ status_t SensorService::enable(const sp<SensorEventConnection>& connection,
     // to maintain the on-change logic (any on-change events except the initial
     // one should be trigger by a change in value). Also if this sensor isn't
     // already active, don't call flush().
+    const SensorDevice& device(SensorDevice::getInstance());
     if (err == NO_ERROR &&
             sensor->getSensor().getReportingMode() != AREPORTING_MODE_ONE_SHOT &&
             sensor->getSensor().getReportingMode() != AREPORTING_MODE_ON_CHANGE &&
             rec->getNumConnections() > 1) {
-        connection->setFirstFlushPending(handle, true);
-        status_t err_flush = sensor->flush(connection.get(), handle);
-        // Flush may return error if the underlying h/w sensor uses an older HAL.
-        if (err_flush == NO_ERROR) {
-            rec->addPendingFlushConnection(connection.get());
-        } else {
-            connection->setFirstFlushPending(handle, false);
+        if (device.getHalDeviceVersion() >= SENSORS_DEVICE_API_VERSION_1_1) {
+            connection->setFirstFlushPending(handle, true);
+            status_t err_flush = sensor->flush(connection.get(), handle);
+            // Flush may return error if the underlying h/w sensor uses an older HAL.
+            if (err_flush == NO_ERROR) {
+                rec->addPendingFlushConnection(connection.get());
+            } else {
+                connection->setFirstFlushPending(handle, false);
+            }
         }
     }
 
+
     if (err == NO_ERROR) {
         ALOGD_IF(DEBUG_CONNECTIONS, "Calling activate on %d", handle);
         err = sensor->activate(connection.get(), true);
@@ -954,6 +959,11 @@ status_t SensorService::enable(const sp<SensorEventConnection>& connection,
         mNextSensorRegIndex = (mNextSensorRegIndex + 1) % SENSOR_REGISTRATIONS_BUF_SIZE;
     }
 
+    if (device.getHalDeviceVersion() < SENSORS_DEVICE_API_VERSION_1_1) {
+        // Pre-1.1 sensor HALs had no flush method, and relied on setDelay at init
+        sensor->setDelay(connection.get(), handle, samplingPeriodNs);
+    }
+
     if (err != NO_ERROR) {
         // batch/activate has failed, reset our state.
         cleanupWithoutDisableLocked(connection, handle);
diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
old mode 100644
new mode 100755
index 1eb2361..30b6e87
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -51,6 +51,10 @@ ifeq ($(TARGET_DISABLE_TRIPLE_BUFFERING),true)
     LOCAL_CFLAGS += -DTARGET_DISABLE_TRIPLE_BUFFERING
 endif
 
+ifeq ($(BOARD_EGL_NEEDS_LEGACY_FB),true)
+	LOCAL_CFLAGS += -DBOARD_EGL_NEEDS_LEGACY_FB
+endif
+
 ifeq ($(TARGET_FORCE_HWC_FOR_VIRTUAL_DISPLAYS),true)
     LOCAL_CFLAGS += -DFORCE_HWC_COPY_FOR_VIRTUAL_DISPLAYS
 endif
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
old mode 100644
new mode 100755
index 5ff79a9..603058c
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -134,7 +134,7 @@ void Layer::onFirstRef() {
     mSurfaceFlingerConsumer->setName(mName);
 
 #ifdef TARGET_DISABLE_TRIPLE_BUFFERING
-#warning "disabling triple buffering"
+//#warning "disabling triple buffering"
     mSurfaceFlingerConsumer->setDefaultMaxBufferCount(2);
 #else
     mSurfaceFlingerConsumer->setDefaultMaxBufferCount(3);
